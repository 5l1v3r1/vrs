
// Copyright © 2010 onwards, Andrew Whewell
// All rights reserved.
//
// Redistribution and use of this software in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
//    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
//    * Neither the name of the author nor the names of the program's contributors may be used to endorse or promote products derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OF THE SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// ===========================================================================================
//                           This file is generated by a T4 script
//   ANY CHANGES MADE DIRECTLY TO THIS FILE WILL BE LOST THE NEXT TIME THE FILE IS GENERATED
// ===========================================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;

namespace VirtualRadar.Resources
{
    /// <summary>
    /// A static class that exposes all of the images in the common resources.
    /// </summary>
    /// <remarks><para>
    /// These images are read/write properties. The application never writes to the properties but
    /// a plugin that wanted to change the graphics used by the application could do so by assigning
    /// new images to the appropriate properties of the class. Care should be taken to allow enough
    /// room on images that are rotated by the website and to replace existing images with images
    /// of the same dimensions and colour depth.
    /// </para><para>
    /// Assigning null to an image resets it back to the default image.
    /// </para></remarks>
    public static class Images
    {
        private static Bitmap _Add16x16;
        /// <summary>
        /// Gets or sets the Add16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Add16x16.png" alt="" title="Add16x16" />
        /// </remarks>
        public static Bitmap Add16x16
        {
            get { return _Add16x16 ?? InternalResources.Add16x16; }
            set { _Add16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Add16x16"/> image has been customised or not.
        /// </summary>
        public static bool Add16x16_IsCustom
        {
            get { return _Add16x16 != null; }
        }

        private static object _Add16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Add16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Add16x16_SyncLock
        {
            get { return _Add16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Add16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Add16x16()
        {
            lock(Add16x16_SyncLock) {
                return new Bitmap(Add16x16);
            }
        }

        private static Icon _ApplicationIcon;
        /// <summary>
        /// Gets or sets the ApplicationIcon image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/ApplicationIcon.ico" alt="" title="ApplicationIcon" />
        /// </remarks>
        public static Icon ApplicationIcon
        {
            get { return _ApplicationIcon ?? InternalResources.ApplicationIcon; }
            set { _ApplicationIcon = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="ApplicationIcon"/> image has been customised or not.
        /// </summary>
        public static bool ApplicationIcon_IsCustom
        {
            get { return _ApplicationIcon != null; }
        }

        private static object _ApplicationIcon_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="ApplicationIcon"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object ApplicationIcon_SyncLock
        {
            get { return _ApplicationIcon_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="ApplicationIcon"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Icon Clone_ApplicationIcon()
        {
            lock(ApplicationIcon_SyncLock) {
                return Icon.FromHandle(ApplicationIcon.Handle);
            }
        }

        private static Bitmap _ArrowBack16x16;
        /// <summary>
        /// Gets or sets the ArrowBack16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/ArrowBack16x16.png" alt="" title="ArrowBack16x16" />
        /// </remarks>
        public static Bitmap ArrowBack16x16
        {
            get { return _ArrowBack16x16 ?? InternalResources.ArrowBack16x16; }
            set { _ArrowBack16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="ArrowBack16x16"/> image has been customised or not.
        /// </summary>
        public static bool ArrowBack16x16_IsCustom
        {
            get { return _ArrowBack16x16 != null; }
        }

        private static object _ArrowBack16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="ArrowBack16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object ArrowBack16x16_SyncLock
        {
            get { return _ArrowBack16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="ArrowBack16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_ArrowBack16x16()
        {
            lock(ArrowBack16x16_SyncLock) {
                return new Bitmap(ArrowBack16x16);
            }
        }

        private static Bitmap _ArrowForward16x16;
        /// <summary>
        /// Gets or sets the ArrowForward16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/ArrowForward16x16.png" alt="" title="ArrowForward16x16" />
        /// </remarks>
        public static Bitmap ArrowForward16x16
        {
            get { return _ArrowForward16x16 ?? InternalResources.ArrowForward16x16; }
            set { _ArrowForward16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="ArrowForward16x16"/> image has been customised or not.
        /// </summary>
        public static bool ArrowForward16x16_IsCustom
        {
            get { return _ArrowForward16x16 != null; }
        }

        private static object _ArrowForward16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="ArrowForward16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object ArrowForward16x16_SyncLock
        {
            get { return _ArrowForward16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="ArrowForward16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_ArrowForward16x16()
        {
            lock(ArrowForward16x16_SyncLock) {
                return new Bitmap(ArrowForward16x16);
            }
        }

        private static Bitmap _BlueBall;
        /// <summary>
        /// Gets or sets the BlueBall image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/BlueBall.png" alt="" title="BlueBall" />
        /// </remarks>
        public static Bitmap BlueBall
        {
            get { return _BlueBall ?? InternalResources.BlueBall; }
            set { _BlueBall = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="BlueBall"/> image has been customised or not.
        /// </summary>
        public static bool BlueBall_IsCustom
        {
            get { return _BlueBall != null; }
        }

        private static object _BlueBall_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="BlueBall"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object BlueBall_SyncLock
        {
            get { return _BlueBall_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="BlueBall"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_BlueBall()
        {
            lock(BlueBall_SyncLock) {
                return new Bitmap(BlueBall);
            }
        }

        private static Bitmap _Cancel16x16;
        /// <summary>
        /// Gets or sets the Cancel16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Cancel16x16.png" alt="" title="Cancel16x16" />
        /// </remarks>
        public static Bitmap Cancel16x16
        {
            get { return _Cancel16x16 ?? InternalResources.Cancel16x16; }
            set { _Cancel16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Cancel16x16"/> image has been customised or not.
        /// </summary>
        public static bool Cancel16x16_IsCustom
        {
            get { return _Cancel16x16 != null; }
        }

        private static object _Cancel16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Cancel16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Cancel16x16_SyncLock
        {
            get { return _Cancel16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Cancel16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Cancel16x16()
        {
            lock(Cancel16x16_SyncLock) {
                return new Bitmap(Cancel16x16);
            }
        }

        private static Bitmap _CancelSmall16x16;
        /// <summary>
        /// Gets or sets the CancelSmall16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/CancelSmall16x16.png" alt="" title="CancelSmall16x16" />
        /// </remarks>
        public static Bitmap CancelSmall16x16
        {
            get { return _CancelSmall16x16 ?? InternalResources.CancelSmall16x16; }
            set { _CancelSmall16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="CancelSmall16x16"/> image has been customised or not.
        /// </summary>
        public static bool CancelSmall16x16_IsCustom
        {
            get { return _CancelSmall16x16 != null; }
        }

        private static object _CancelSmall16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="CancelSmall16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object CancelSmall16x16_SyncLock
        {
            get { return _CancelSmall16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="CancelSmall16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_CancelSmall16x16()
        {
            lock(CancelSmall16x16_SyncLock) {
                return new Bitmap(CancelSmall16x16);
            }
        }

        private static Bitmap _ChevronBlueCircle;
        /// <summary>
        /// Gets or sets the ChevronBlueCircle image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/ChevronBlueCircle.png" alt="" title="ChevronBlueCircle" />
        /// </remarks>
        public static Bitmap ChevronBlueCircle
        {
            get { return _ChevronBlueCircle ?? InternalResources.ChevronBlueCircle; }
            set { _ChevronBlueCircle = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="ChevronBlueCircle"/> image has been customised or not.
        /// </summary>
        public static bool ChevronBlueCircle_IsCustom
        {
            get { return _ChevronBlueCircle != null; }
        }

        private static object _ChevronBlueCircle_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="ChevronBlueCircle"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object ChevronBlueCircle_SyncLock
        {
            get { return _ChevronBlueCircle_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="ChevronBlueCircle"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_ChevronBlueCircle()
        {
            lock(ChevronBlueCircle_SyncLock) {
                return new Bitmap(ChevronBlueCircle);
            }
        }

        private static Bitmap _ChevronGreenCircle;
        /// <summary>
        /// Gets or sets the ChevronGreenCircle image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/ChevronGreenCircle.png" alt="" title="ChevronGreenCircle" />
        /// </remarks>
        public static Bitmap ChevronGreenCircle
        {
            get { return _ChevronGreenCircle ?? InternalResources.ChevronGreenCircle; }
            set { _ChevronGreenCircle = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="ChevronGreenCircle"/> image has been customised or not.
        /// </summary>
        public static bool ChevronGreenCircle_IsCustom
        {
            get { return _ChevronGreenCircle != null; }
        }

        private static object _ChevronGreenCircle_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="ChevronGreenCircle"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object ChevronGreenCircle_SyncLock
        {
            get { return _ChevronGreenCircle_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="ChevronGreenCircle"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_ChevronGreenCircle()
        {
            lock(ChevronGreenCircle_SyncLock) {
                return new Bitmap(ChevronGreenCircle);
            }
        }

        private static Bitmap _ChevronRedCircle;
        /// <summary>
        /// Gets or sets the ChevronRedCircle image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/ChevronRedCircle.png" alt="" title="ChevronRedCircle" />
        /// </remarks>
        public static Bitmap ChevronRedCircle
        {
            get { return _ChevronRedCircle ?? InternalResources.ChevronRedCircle; }
            set { _ChevronRedCircle = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="ChevronRedCircle"/> image has been customised or not.
        /// </summary>
        public static bool ChevronRedCircle_IsCustom
        {
            get { return _ChevronRedCircle != null; }
        }

        private static object _ChevronRedCircle_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="ChevronRedCircle"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object ChevronRedCircle_SyncLock
        {
            get { return _ChevronRedCircle_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="ChevronRedCircle"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_ChevronRedCircle()
        {
            lock(ChevronRedCircle_SyncLock) {
                return new Bitmap(ChevronRedCircle);
            }
        }

        private static Bitmap _CloseSlider;
        /// <summary>
        /// Gets or sets the CloseSlider image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/CloseSlider.png" alt="" title="CloseSlider" />
        /// </remarks>
        public static Bitmap CloseSlider
        {
            get { return _CloseSlider ?? InternalResources.CloseSlider; }
            set { _CloseSlider = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="CloseSlider"/> image has been customised or not.
        /// </summary>
        public static bool CloseSlider_IsCustom
        {
            get { return _CloseSlider != null; }
        }

        private static object _CloseSlider_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="CloseSlider"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object CloseSlider_SyncLock
        {
            get { return _CloseSlider_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="CloseSlider"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_CloseSlider()
        {
            lock(CloseSlider_SyncLock) {
                return new Bitmap(CloseSlider);
            }
        }

        private static Bitmap _Collapse;
        /// <summary>
        /// Gets or sets the Collapse image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Collapse.png" alt="" title="Collapse" />
        /// </remarks>
        public static Bitmap Collapse
        {
            get { return _Collapse ?? InternalResources.Collapse; }
            set { _Collapse = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Collapse"/> image has been customised or not.
        /// </summary>
        public static bool Collapse_IsCustom
        {
            get { return _Collapse != null; }
        }

        private static object _Collapse_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Collapse"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Collapse_SyncLock
        {
            get { return _Collapse_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Collapse"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Collapse()
        {
            lock(Collapse_SyncLock) {
                return new Bitmap(Collapse);
            }
        }

        private static Bitmap _Compass;
        /// <summary>
        /// Gets or sets the Compass image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Compass.png" alt="" title="Compass" />
        /// </remarks>
        public static Bitmap Compass
        {
            get { return _Compass ?? InternalResources.Compass; }
            set { _Compass = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Compass"/> image has been customised or not.
        /// </summary>
        public static bool Compass_IsCustom
        {
            get { return _Compass != null; }
        }

        private static object _Compass_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Compass"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Compass_SyncLock
        {
            get { return _Compass_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Compass"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Compass()
        {
            lock(Compass_SyncLock) {
                return new Bitmap(Compass);
            }
        }

        private static Bitmap _Corner_BottomLeft;
        /// <summary>
        /// Gets or sets the Corner_BottomLeft image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Corner_BottomLeft.png" alt="" title="Corner_BottomLeft" />
        /// </remarks>
        public static Bitmap Corner_BottomLeft
        {
            get { return _Corner_BottomLeft ?? InternalResources.Corner_BottomLeft; }
            set { _Corner_BottomLeft = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Corner_BottomLeft"/> image has been customised or not.
        /// </summary>
        public static bool Corner_BottomLeft_IsCustom
        {
            get { return _Corner_BottomLeft != null; }
        }

        private static object _Corner_BottomLeft_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Corner_BottomLeft"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Corner_BottomLeft_SyncLock
        {
            get { return _Corner_BottomLeft_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Corner_BottomLeft"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Corner_BottomLeft()
        {
            lock(Corner_BottomLeft_SyncLock) {
                return new Bitmap(Corner_BottomLeft);
            }
        }

        private static Bitmap _Corner_BottomRight;
        /// <summary>
        /// Gets or sets the Corner_BottomRight image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Corner_BottomRight.png" alt="" title="Corner_BottomRight" />
        /// </remarks>
        public static Bitmap Corner_BottomRight
        {
            get { return _Corner_BottomRight ?? InternalResources.Corner_BottomRight; }
            set { _Corner_BottomRight = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Corner_BottomRight"/> image has been customised or not.
        /// </summary>
        public static bool Corner_BottomRight_IsCustom
        {
            get { return _Corner_BottomRight != null; }
        }

        private static object _Corner_BottomRight_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Corner_BottomRight"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Corner_BottomRight_SyncLock
        {
            get { return _Corner_BottomRight_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Corner_BottomRight"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Corner_BottomRight()
        {
            lock(Corner_BottomRight_SyncLock) {
                return new Bitmap(Corner_BottomRight);
            }
        }

        private static Bitmap _Corner_TopLeft;
        /// <summary>
        /// Gets or sets the Corner_TopLeft image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Corner_TopLeft.png" alt="" title="Corner_TopLeft" />
        /// </remarks>
        public static Bitmap Corner_TopLeft
        {
            get { return _Corner_TopLeft ?? InternalResources.Corner_TopLeft; }
            set { _Corner_TopLeft = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Corner_TopLeft"/> image has been customised or not.
        /// </summary>
        public static bool Corner_TopLeft_IsCustom
        {
            get { return _Corner_TopLeft != null; }
        }

        private static object _Corner_TopLeft_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Corner_TopLeft"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Corner_TopLeft_SyncLock
        {
            get { return _Corner_TopLeft_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Corner_TopLeft"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Corner_TopLeft()
        {
            lock(Corner_TopLeft_SyncLock) {
                return new Bitmap(Corner_TopLeft);
            }
        }

        private static Bitmap _Corner_TopRight;
        /// <summary>
        /// Gets or sets the Corner_TopRight image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Corner_TopRight.png" alt="" title="Corner_TopRight" />
        /// </remarks>
        public static Bitmap Corner_TopRight
        {
            get { return _Corner_TopRight ?? InternalResources.Corner_TopRight; }
            set { _Corner_TopRight = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Corner_TopRight"/> image has been customised or not.
        /// </summary>
        public static bool Corner_TopRight_IsCustom
        {
            get { return _Corner_TopRight != null; }
        }

        private static object _Corner_TopRight_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Corner_TopRight"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Corner_TopRight_SyncLock
        {
            get { return _Corner_TopRight_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Corner_TopRight"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Corner_TopRight()
        {
            lock(Corner_TopRight_SyncLock) {
                return new Bitmap(Corner_TopRight);
            }
        }

        private static Bitmap _Crosshair;
        /// <summary>
        /// Gets or sets the Crosshair image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Crosshair.png" alt="" title="Crosshair" />
        /// </remarks>
        public static Bitmap Crosshair
        {
            get { return _Crosshair ?? InternalResources.Crosshair; }
            set { _Crosshair = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Crosshair"/> image has been customised or not.
        /// </summary>
        public static bool Crosshair_IsCustom
        {
            get { return _Crosshair != null; }
        }

        private static object _Crosshair_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Crosshair"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Crosshair_SyncLock
        {
            get { return _Crosshair_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Crosshair"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Crosshair()
        {
            lock(Crosshair_SyncLock) {
                return new Bitmap(Crosshair);
            }
        }

        private static Bitmap _Decoding16x16;
        /// <summary>
        /// Gets or sets the Decoding16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Decoding16x16.png" alt="" title="Decoding16x16" />
        /// </remarks>
        public static Bitmap Decoding16x16
        {
            get { return _Decoding16x16 ?? InternalResources.Decoding16x16; }
            set { _Decoding16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Decoding16x16"/> image has been customised or not.
        /// </summary>
        public static bool Decoding16x16_IsCustom
        {
            get { return _Decoding16x16 != null; }
        }

        private static object _Decoding16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Decoding16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Decoding16x16_SyncLock
        {
            get { return _Decoding16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Decoding16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Decoding16x16()
        {
            lock(Decoding16x16_SyncLock) {
                return new Bitmap(Decoding16x16);
            }
        }

        private static Bitmap _Edit16x16;
        /// <summary>
        /// Gets or sets the Edit16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Edit16x16.png" alt="" title="Edit16x16" />
        /// </remarks>
        public static Bitmap Edit16x16
        {
            get { return _Edit16x16 ?? InternalResources.Edit16x16; }
            set { _Edit16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Edit16x16"/> image has been customised or not.
        /// </summary>
        public static bool Edit16x16_IsCustom
        {
            get { return _Edit16x16 != null; }
        }

        private static object _Edit16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Edit16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Edit16x16_SyncLock
        {
            get { return _Edit16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Edit16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Edit16x16()
        {
            lock(Edit16x16_SyncLock) {
                return new Bitmap(Edit16x16);
            }
        }

        private static Bitmap _Expand;
        /// <summary>
        /// Gets or sets the Expand image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Expand.png" alt="" title="Expand" />
        /// </remarks>
        public static Bitmap Expand
        {
            get { return _Expand ?? InternalResources.Expand; }
            set { _Expand = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Expand"/> image has been customised or not.
        /// </summary>
        public static bool Expand_IsCustom
        {
            get { return _Expand != null; }
        }

        private static object _Expand_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Expand"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Expand_SyncLock
        {
            get { return _Expand_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Expand"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Expand()
        {
            lock(Expand_SyncLock) {
                return new Bitmap(Expand);
            }
        }

        private static Icon _Favicon;
        /// <summary>
        /// Gets or sets the Favicon image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Favicon.ico" alt="" title="Favicon" />
        /// </remarks>
        public static Icon Favicon
        {
            get { return _Favicon ?? InternalResources.Favicon; }
            set { _Favicon = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Favicon"/> image has been customised or not.
        /// </summary>
        public static bool Favicon_IsCustom
        {
            get { return _Favicon != null; }
        }

        private static object _Favicon_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Favicon"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Favicon_SyncLock
        {
            get { return _Favicon_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Favicon"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Icon Clone_Favicon()
        {
            lock(Favicon_SyncLock) {
                return Icon.FromHandle(Favicon.Handle);
            }
        }

        private static Bitmap _FollowMe;
        /// <summary>
        /// Gets or sets the FollowMe image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/FollowMe.png" alt="" title="FollowMe" />
        /// </remarks>
        public static Bitmap FollowMe
        {
            get { return _FollowMe ?? InternalResources.FollowMe; }
            set { _FollowMe = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="FollowMe"/> image has been customised or not.
        /// </summary>
        public static bool FollowMe_IsCustom
        {
            get { return _FollowMe != null; }
        }

        private static object _FollowMe_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="FollowMe"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object FollowMe_SyncLock
        {
            get { return _FollowMe_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="FollowMe"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_FollowMe()
        {
            lock(FollowMe_SyncLock) {
                return new Bitmap(FollowMe);
            }
        }

        private static Bitmap _Gear16x16;
        /// <summary>
        /// Gets or sets the Gear16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Gear16x16.png" alt="" title="Gear16x16" />
        /// </remarks>
        public static Bitmap Gear16x16
        {
            get { return _Gear16x16 ?? InternalResources.Gear16x16; }
            set { _Gear16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Gear16x16"/> image has been customised or not.
        /// </summary>
        public static bool Gear16x16_IsCustom
        {
            get { return _Gear16x16 != null; }
        }

        private static object _Gear16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Gear16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Gear16x16_SyncLock
        {
            get { return _Gear16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Gear16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Gear16x16()
        {
            lock(Gear16x16_SyncLock) {
                return new Bitmap(Gear16x16);
            }
        }

        private static Bitmap _GotoCurrentLocation;
        /// <summary>
        /// Gets or sets the GotoCurrentLocation image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/GotoCurrentLocation.png" alt="" title="GotoCurrentLocation" />
        /// </remarks>
        public static Bitmap GotoCurrentLocation
        {
            get { return _GotoCurrentLocation ?? InternalResources.GotoCurrentLocation; }
            set { _GotoCurrentLocation = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="GotoCurrentLocation"/> image has been customised or not.
        /// </summary>
        public static bool GotoCurrentLocation_IsCustom
        {
            get { return _GotoCurrentLocation != null; }
        }

        private static object _GotoCurrentLocation_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="GotoCurrentLocation"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object GotoCurrentLocation_SyncLock
        {
            get { return _GotoCurrentLocation_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="GotoCurrentLocation"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_GotoCurrentLocation()
        {
            lock(GotoCurrentLocation_SyncLock) {
                return new Bitmap(GotoCurrentLocation);
            }
        }

        private static Bitmap _HelpAbout;
        /// <summary>
        /// Gets or sets the HelpAbout image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/HelpAbout.png" alt="" title="HelpAbout" />
        /// </remarks>
        public static Bitmap HelpAbout
        {
            get { return _HelpAbout ?? InternalResources.HelpAbout; }
            set { _HelpAbout = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="HelpAbout"/> image has been customised or not.
        /// </summary>
        public static bool HelpAbout_IsCustom
        {
            get { return _HelpAbout != null; }
        }

        private static object _HelpAbout_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="HelpAbout"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object HelpAbout_SyncLock
        {
            get { return _HelpAbout_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="HelpAbout"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_HelpAbout()
        {
            lock(HelpAbout_SyncLock) {
                return new Bitmap(HelpAbout);
            }
        }

        private static Bitmap _HideList;
        /// <summary>
        /// Gets or sets the HideList image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/HideList.png" alt="" title="HideList" />
        /// </remarks>
        public static Bitmap HideList
        {
            get { return _HideList ?? InternalResources.HideList; }
            set { _HideList = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="HideList"/> image has been customised or not.
        /// </summary>
        public static bool HideList_IsCustom
        {
            get { return _HideList != null; }
        }

        private static object _HideList_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="HideList"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object HideList_SyncLock
        {
            get { return _HideList_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="HideList"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_HideList()
        {
            lock(HideList_SyncLock) {
                return new Bitmap(HideList);
            }
        }

        private static Bitmap _IPadSplash;
        /// <summary>
        /// Gets or sets the IPadSplash image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/IPadSplash.png" alt="" title="IPadSplash" />
        /// </remarks>
        public static Bitmap IPadSplash
        {
            get { return _IPadSplash ?? InternalResources.IPadSplash; }
            set { _IPadSplash = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="IPadSplash"/> image has been customised or not.
        /// </summary>
        public static bool IPadSplash_IsCustom
        {
            get { return _IPadSplash != null; }
        }

        private static object _IPadSplash_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="IPadSplash"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object IPadSplash_SyncLock
        {
            get { return _IPadSplash_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="IPadSplash"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_IPadSplash()
        {
            lock(IPadSplash_SyncLock) {
                return new Bitmap(IPadSplash);
            }
        }

        private static Bitmap _IPhoneBackButton;
        /// <summary>
        /// Gets or sets the IPhoneBackButton image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/IPhoneBackButton.png" alt="" title="IPhoneBackButton" />
        /// </remarks>
        public static Bitmap IPhoneBackButton
        {
            get { return _IPhoneBackButton ?? InternalResources.IPhoneBackButton; }
            set { _IPhoneBackButton = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="IPhoneBackButton"/> image has been customised or not.
        /// </summary>
        public static bool IPhoneBackButton_IsCustom
        {
            get { return _IPhoneBackButton != null; }
        }

        private static object _IPhoneBackButton_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="IPhoneBackButton"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object IPhoneBackButton_SyncLock
        {
            get { return _IPhoneBackButton_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="IPhoneBackButton"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_IPhoneBackButton()
        {
            lock(IPhoneBackButton_SyncLock) {
                return new Bitmap(IPhoneBackButton);
            }
        }

        private static Bitmap _IPhoneBlueButton;
        /// <summary>
        /// Gets or sets the IPhoneBlueButton image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/IPhoneBlueButton.png" alt="" title="IPhoneBlueButton" />
        /// </remarks>
        public static Bitmap IPhoneBlueButton
        {
            get { return _IPhoneBlueButton ?? InternalResources.IPhoneBlueButton; }
            set { _IPhoneBlueButton = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="IPhoneBlueButton"/> image has been customised or not.
        /// </summary>
        public static bool IPhoneBlueButton_IsCustom
        {
            get { return _IPhoneBlueButton != null; }
        }

        private static object _IPhoneBlueButton_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="IPhoneBlueButton"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object IPhoneBlueButton_SyncLock
        {
            get { return _IPhoneBlueButton_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="IPhoneBlueButton"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_IPhoneBlueButton()
        {
            lock(IPhoneBlueButton_SyncLock) {
                return new Bitmap(IPhoneBlueButton);
            }
        }

        private static Bitmap _IPhoneChevron;
        /// <summary>
        /// Gets or sets the IPhoneChevron image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/IPhoneChevron.png" alt="" title="IPhoneChevron" />
        /// </remarks>
        public static Bitmap IPhoneChevron
        {
            get { return _IPhoneChevron ?? InternalResources.IPhoneChevron; }
            set { _IPhoneChevron = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="IPhoneChevron"/> image has been customised or not.
        /// </summary>
        public static bool IPhoneChevron_IsCustom
        {
            get { return _IPhoneChevron != null; }
        }

        private static object _IPhoneChevron_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="IPhoneChevron"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object IPhoneChevron_SyncLock
        {
            get { return _IPhoneChevron_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="IPhoneChevron"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_IPhoneChevron()
        {
            lock(IPhoneChevron_SyncLock) {
                return new Bitmap(IPhoneChevron);
            }
        }

        private static Bitmap _IPhoneGrayButton;
        /// <summary>
        /// Gets or sets the IPhoneGrayButton image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/IPhoneGrayButton.png" alt="" title="IPhoneGrayButton" />
        /// </remarks>
        public static Bitmap IPhoneGrayButton
        {
            get { return _IPhoneGrayButton ?? InternalResources.IPhoneGrayButton; }
            set { _IPhoneGrayButton = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="IPhoneGrayButton"/> image has been customised or not.
        /// </summary>
        public static bool IPhoneGrayButton_IsCustom
        {
            get { return _IPhoneGrayButton != null; }
        }

        private static object _IPhoneGrayButton_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="IPhoneGrayButton"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object IPhoneGrayButton_SyncLock
        {
            get { return _IPhoneGrayButton_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="IPhoneGrayButton"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_IPhoneGrayButton()
        {
            lock(IPhoneGrayButton_SyncLock) {
                return new Bitmap(IPhoneGrayButton);
            }
        }

        private static Bitmap _IPhoneIcon;
        /// <summary>
        /// Gets or sets the IPhoneIcon image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/IPhoneIcon.png" alt="" title="IPhoneIcon" />
        /// </remarks>
        public static Bitmap IPhoneIcon
        {
            get { return _IPhoneIcon ?? InternalResources.IPhoneIcon; }
            set { _IPhoneIcon = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="IPhoneIcon"/> image has been customised or not.
        /// </summary>
        public static bool IPhoneIcon_IsCustom
        {
            get { return _IPhoneIcon != null; }
        }

        private static object _IPhoneIcon_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="IPhoneIcon"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object IPhoneIcon_SyncLock
        {
            get { return _IPhoneIcon_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="IPhoneIcon"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_IPhoneIcon()
        {
            lock(IPhoneIcon_SyncLock) {
                return new Bitmap(IPhoneIcon);
            }
        }

        private static Bitmap _IPhoneListGroup;
        /// <summary>
        /// Gets or sets the IPhoneListGroup image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/IPhoneListGroup.png" alt="" title="IPhoneListGroup" />
        /// </remarks>
        public static Bitmap IPhoneListGroup
        {
            get { return _IPhoneListGroup ?? InternalResources.IPhoneListGroup; }
            set { _IPhoneListGroup = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="IPhoneListGroup"/> image has been customised or not.
        /// </summary>
        public static bool IPhoneListGroup_IsCustom
        {
            get { return _IPhoneListGroup != null; }
        }

        private static object _IPhoneListGroup_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="IPhoneListGroup"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object IPhoneListGroup_SyncLock
        {
            get { return _IPhoneListGroup_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="IPhoneListGroup"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_IPhoneListGroup()
        {
            lock(IPhoneListGroup_SyncLock) {
                return new Bitmap(IPhoneListGroup);
            }
        }

        private static Bitmap _IPhoneOnOff;
        /// <summary>
        /// Gets or sets the IPhoneOnOff image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/IPhoneOnOff.png" alt="" title="IPhoneOnOff" />
        /// </remarks>
        public static Bitmap IPhoneOnOff
        {
            get { return _IPhoneOnOff ?? InternalResources.IPhoneOnOff; }
            set { _IPhoneOnOff = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="IPhoneOnOff"/> image has been customised or not.
        /// </summary>
        public static bool IPhoneOnOff_IsCustom
        {
            get { return _IPhoneOnOff != null; }
        }

        private static object _IPhoneOnOff_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="IPhoneOnOff"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object IPhoneOnOff_SyncLock
        {
            get { return _IPhoneOnOff_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="IPhoneOnOff"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_IPhoneOnOff()
        {
            lock(IPhoneOnOff_SyncLock) {
                return new Bitmap(IPhoneOnOff);
            }
        }

        private static Bitmap _IPhonePinstripes;
        /// <summary>
        /// Gets or sets the IPhonePinstripes image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/IPhonePinstripes.png" alt="" title="IPhonePinstripes" />
        /// </remarks>
        public static Bitmap IPhonePinstripes
        {
            get { return _IPhonePinstripes ?? InternalResources.IPhonePinstripes; }
            set { _IPhonePinstripes = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="IPhonePinstripes"/> image has been customised or not.
        /// </summary>
        public static bool IPhonePinstripes_IsCustom
        {
            get { return _IPhonePinstripes != null; }
        }

        private static object _IPhonePinstripes_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="IPhonePinstripes"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object IPhonePinstripes_SyncLock
        {
            get { return _IPhonePinstripes_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="IPhonePinstripes"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_IPhonePinstripes()
        {
            lock(IPhonePinstripes_SyncLock) {
                return new Bitmap(IPhonePinstripes);
            }
        }

        private static Bitmap _IPhoneSelectedTick;
        /// <summary>
        /// Gets or sets the IPhoneSelectedTick image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/IPhoneSelectedTick.png" alt="" title="IPhoneSelectedTick" />
        /// </remarks>
        public static Bitmap IPhoneSelectedTick
        {
            get { return _IPhoneSelectedTick ?? InternalResources.IPhoneSelectedTick; }
            set { _IPhoneSelectedTick = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="IPhoneSelectedTick"/> image has been customised or not.
        /// </summary>
        public static bool IPhoneSelectedTick_IsCustom
        {
            get { return _IPhoneSelectedTick != null; }
        }

        private static object _IPhoneSelectedTick_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="IPhoneSelectedTick"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object IPhoneSelectedTick_SyncLock
        {
            get { return _IPhoneSelectedTick_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="IPhoneSelectedTick"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_IPhoneSelectedTick()
        {
            lock(IPhoneSelectedTick_SyncLock) {
                return new Bitmap(IPhoneSelectedTick);
            }
        }

        private static Bitmap _IPhoneSelection;
        /// <summary>
        /// Gets or sets the IPhoneSelection image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/IPhoneSelection.png" alt="" title="IPhoneSelection" />
        /// </remarks>
        public static Bitmap IPhoneSelection
        {
            get { return _IPhoneSelection ?? InternalResources.IPhoneSelection; }
            set { _IPhoneSelection = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="IPhoneSelection"/> image has been customised or not.
        /// </summary>
        public static bool IPhoneSelection_IsCustom
        {
            get { return _IPhoneSelection != null; }
        }

        private static object _IPhoneSelection_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="IPhoneSelection"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object IPhoneSelection_SyncLock
        {
            get { return _IPhoneSelection_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="IPhoneSelection"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_IPhoneSelection()
        {
            lock(IPhoneSelection_SyncLock) {
                return new Bitmap(IPhoneSelection);
            }
        }

        private static Bitmap _IPhoneSplash;
        /// <summary>
        /// Gets or sets the IPhoneSplash image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/IPhoneSplash.png" alt="" title="IPhoneSplash" />
        /// </remarks>
        public static Bitmap IPhoneSplash
        {
            get { return _IPhoneSplash ?? InternalResources.IPhoneSplash; }
            set { _IPhoneSplash = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="IPhoneSplash"/> image has been customised or not.
        /// </summary>
        public static bool IPhoneSplash_IsCustom
        {
            get { return _IPhoneSplash != null; }
        }

        private static object _IPhoneSplash_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="IPhoneSplash"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object IPhoneSplash_SyncLock
        {
            get { return _IPhoneSplash_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="IPhoneSplash"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_IPhoneSplash()
        {
            lock(IPhoneSplash_SyncLock) {
                return new Bitmap(IPhoneSplash);
            }
        }

        private static Bitmap _IPhoneToolbar;
        /// <summary>
        /// Gets or sets the IPhoneToolbar image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/IPhoneToolbar.png" alt="" title="IPhoneToolbar" />
        /// </remarks>
        public static Bitmap IPhoneToolbar
        {
            get { return _IPhoneToolbar ?? InternalResources.IPhoneToolbar; }
            set { _IPhoneToolbar = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="IPhoneToolbar"/> image has been customised or not.
        /// </summary>
        public static bool IPhoneToolbar_IsCustom
        {
            get { return _IPhoneToolbar != null; }
        }

        private static object _IPhoneToolbar_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="IPhoneToolbar"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object IPhoneToolbar_SyncLock
        {
            get { return _IPhoneToolbar_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="IPhoneToolbar"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_IPhoneToolbar()
        {
            lock(IPhoneToolbar_SyncLock) {
                return new Bitmap(IPhoneToolbar);
            }
        }

        private static Bitmap _IPhoneToolButton;
        /// <summary>
        /// Gets or sets the IPhoneToolButton image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/IPhoneToolButton.png" alt="" title="IPhoneToolButton" />
        /// </remarks>
        public static Bitmap IPhoneToolButton
        {
            get { return _IPhoneToolButton ?? InternalResources.IPhoneToolButton; }
            set { _IPhoneToolButton = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="IPhoneToolButton"/> image has been customised or not.
        /// </summary>
        public static bool IPhoneToolButton_IsCustom
        {
            get { return _IPhoneToolButton != null; }
        }

        private static object _IPhoneToolButton_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="IPhoneToolButton"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object IPhoneToolButton_SyncLock
        {
            get { return _IPhoneToolButton_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="IPhoneToolButton"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_IPhoneToolButton()
        {
            lock(IPhoneToolButton_SyncLock) {
                return new Bitmap(IPhoneToolButton);
            }
        }

        private static Bitmap _IPhoneWhiteButton;
        /// <summary>
        /// Gets or sets the IPhoneWhiteButton image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/IPhoneWhiteButton.png" alt="" title="IPhoneWhiteButton" />
        /// </remarks>
        public static Bitmap IPhoneWhiteButton
        {
            get { return _IPhoneWhiteButton ?? InternalResources.IPhoneWhiteButton; }
            set { _IPhoneWhiteButton = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="IPhoneWhiteButton"/> image has been customised or not.
        /// </summary>
        public static bool IPhoneWhiteButton_IsCustom
        {
            get { return _IPhoneWhiteButton != null; }
        }

        private static object _IPhoneWhiteButton_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="IPhoneWhiteButton"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object IPhoneWhiteButton_SyncLock
        {
            get { return _IPhoneWhiteButton_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="IPhoneWhiteButton"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_IPhoneWhiteButton()
        {
            lock(IPhoneWhiteButton_SyncLock) {
                return new Bitmap(IPhoneWhiteButton);
            }
        }

        private static Bitmap _Location16x16;
        /// <summary>
        /// Gets or sets the Location16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Location16x16.png" alt="" title="Location16x16" />
        /// </remarks>
        public static Bitmap Location16x16
        {
            get { return _Location16x16 ?? InternalResources.Location16x16; }
            set { _Location16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Location16x16"/> image has been customised or not.
        /// </summary>
        public static bool Location16x16_IsCustom
        {
            get { return _Location16x16 != null; }
        }

        private static object _Location16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Location16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Location16x16_SyncLock
        {
            get { return _Location16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Location16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Location16x16()
        {
            lock(Location16x16_SyncLock) {
                return new Bitmap(Location16x16);
            }
        }

        private static Bitmap _Logo128x128;
        /// <summary>
        /// Gets or sets the Logo128x128 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Logo128x128.png" alt="" title="Logo128x128" />
        /// </remarks>
        public static Bitmap Logo128x128
        {
            get { return _Logo128x128 ?? InternalResources.Logo128x128; }
            set { _Logo128x128 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Logo128x128"/> image has been customised or not.
        /// </summary>
        public static bool Logo128x128_IsCustom
        {
            get { return _Logo128x128 != null; }
        }

        private static object _Logo128x128_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Logo128x128"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Logo128x128_SyncLock
        {
            get { return _Logo128x128_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Logo128x128"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Logo128x128()
        {
            lock(Logo128x128_SyncLock) {
                return new Bitmap(Logo128x128);
            }
        }

        private static Bitmap _Marker_Airplane;
        /// <summary>
        /// Gets or sets the Marker_Airplane image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Marker_Airplane.png" alt="" title="Marker_Airplane" />
        /// </remarks>
        public static Bitmap Marker_Airplane
        {
            get { return _Marker_Airplane ?? InternalResources.Marker_Airplane; }
            set { _Marker_Airplane = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Marker_Airplane"/> image has been customised or not.
        /// </summary>
        public static bool Marker_Airplane_IsCustom
        {
            get { return _Marker_Airplane != null; }
        }

        private static object _Marker_Airplane_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Marker_Airplane"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Marker_Airplane_SyncLock
        {
            get { return _Marker_Airplane_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Marker_Airplane"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Marker_Airplane()
        {
            lock(Marker_Airplane_SyncLock) {
                return new Bitmap(Marker_Airplane);
            }
        }

        private static Bitmap _Marker_AirplaneSelected;
        /// <summary>
        /// Gets or sets the Marker_AirplaneSelected image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Marker_AirplaneSelected.png" alt="" title="Marker_AirplaneSelected" />
        /// </remarks>
        public static Bitmap Marker_AirplaneSelected
        {
            get { return _Marker_AirplaneSelected ?? InternalResources.Marker_AirplaneSelected; }
            set { _Marker_AirplaneSelected = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Marker_AirplaneSelected"/> image has been customised or not.
        /// </summary>
        public static bool Marker_AirplaneSelected_IsCustom
        {
            get { return _Marker_AirplaneSelected != null; }
        }

        private static object _Marker_AirplaneSelected_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Marker_AirplaneSelected"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Marker_AirplaneSelected_SyncLock
        {
            get { return _Marker_AirplaneSelected_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Marker_AirplaneSelected"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Marker_AirplaneSelected()
        {
            lock(Marker_AirplaneSelected_SyncLock) {
                return new Bitmap(Marker_AirplaneSelected);
            }
        }

        private static Bitmap _MergedFeed16x16;
        /// <summary>
        /// Gets or sets the MergedFeed16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/MergedFeed16x16.png" alt="" title="MergedFeed16x16" />
        /// </remarks>
        public static Bitmap MergedFeed16x16
        {
            get { return _MergedFeed16x16 ?? InternalResources.MergedFeed16x16; }
            set { _MergedFeed16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="MergedFeed16x16"/> image has been customised or not.
        /// </summary>
        public static bool MergedFeed16x16_IsCustom
        {
            get { return _MergedFeed16x16 != null; }
        }

        private static object _MergedFeed16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="MergedFeed16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object MergedFeed16x16_SyncLock
        {
            get { return _MergedFeed16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="MergedFeed16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_MergedFeed16x16()
        {
            lock(MergedFeed16x16_SyncLock) {
                return new Bitmap(MergedFeed16x16);
            }
        }

        private static Bitmap _MovingMapChecked;
        /// <summary>
        /// Gets or sets the MovingMapChecked image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/MovingMapChecked.png" alt="" title="MovingMapChecked" />
        /// </remarks>
        public static Bitmap MovingMapChecked
        {
            get { return _MovingMapChecked ?? InternalResources.MovingMapChecked; }
            set { _MovingMapChecked = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="MovingMapChecked"/> image has been customised or not.
        /// </summary>
        public static bool MovingMapChecked_IsCustom
        {
            get { return _MovingMapChecked != null; }
        }

        private static object _MovingMapChecked_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="MovingMapChecked"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object MovingMapChecked_SyncLock
        {
            get { return _MovingMapChecked_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="MovingMapChecked"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_MovingMapChecked()
        {
            lock(MovingMapChecked_SyncLock) {
                return new Bitmap(MovingMapChecked);
            }
        }

        private static Bitmap _MovingMapUnchecked;
        /// <summary>
        /// Gets or sets the MovingMapUnchecked image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/MovingMapUnchecked.png" alt="" title="MovingMapUnchecked" />
        /// </remarks>
        public static Bitmap MovingMapUnchecked
        {
            get { return _MovingMapUnchecked ?? InternalResources.MovingMapUnchecked; }
            set { _MovingMapUnchecked = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="MovingMapUnchecked"/> image has been customised or not.
        /// </summary>
        public static bool MovingMapUnchecked_IsCustom
        {
            get { return _MovingMapUnchecked != null; }
        }

        private static object _MovingMapUnchecked_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="MovingMapUnchecked"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object MovingMapUnchecked_SyncLock
        {
            get { return _MovingMapUnchecked_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="MovingMapUnchecked"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_MovingMapUnchecked()
        {
            lock(MovingMapUnchecked_SyncLock) {
                return new Bitmap(MovingMapUnchecked);
            }
        }

        private static Bitmap _Notebook16x16;
        /// <summary>
        /// Gets or sets the Notebook16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Notebook16x16.png" alt="" title="Notebook16x16" />
        /// </remarks>
        public static Bitmap Notebook16x16
        {
            get { return _Notebook16x16 ?? InternalResources.Notebook16x16; }
            set { _Notebook16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Notebook16x16"/> image has been customised or not.
        /// </summary>
        public static bool Notebook16x16_IsCustom
        {
            get { return _Notebook16x16 != null; }
        }

        private static object _Notebook16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Notebook16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Notebook16x16_SyncLock
        {
            get { return _Notebook16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Notebook16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Notebook16x16()
        {
            lock(Notebook16x16_SyncLock) {
                return new Bitmap(Notebook16x16);
            }
        }

        private static Bitmap _OpenSlider;
        /// <summary>
        /// Gets or sets the OpenSlider image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/OpenSlider.png" alt="" title="OpenSlider" />
        /// </remarks>
        public static Bitmap OpenSlider
        {
            get { return _OpenSlider ?? InternalResources.OpenSlider; }
            set { _OpenSlider = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="OpenSlider"/> image has been customised or not.
        /// </summary>
        public static bool OpenSlider_IsCustom
        {
            get { return _OpenSlider != null; }
        }

        private static object _OpenSlider_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="OpenSlider"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object OpenSlider_SyncLock
        {
            get { return _OpenSlider_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="OpenSlider"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_OpenSlider()
        {
            lock(OpenSlider_SyncLock) {
                return new Bitmap(OpenSlider);
            }
        }

        private static Bitmap _Radio16x16;
        /// <summary>
        /// Gets or sets the Radio16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Radio16x16.png" alt="" title="Radio16x16" />
        /// </remarks>
        public static Bitmap Radio16x16
        {
            get { return _Radio16x16 ?? InternalResources.Radio16x16; }
            set { _Radio16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Radio16x16"/> image has been customised or not.
        /// </summary>
        public static bool Radio16x16_IsCustom
        {
            get { return _Radio16x16 != null; }
        }

        private static object _Radio16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Radio16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Radio16x16_SyncLock
        {
            get { return _Radio16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Radio16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Radio16x16()
        {
            lock(Radio16x16_SyncLock) {
                return new Bitmap(Radio16x16);
            }
        }

        private static Bitmap _Radio48x48;
        /// <summary>
        /// Gets or sets the Radio48x48 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Radio48x48.png" alt="" title="Radio48x48" />
        /// </remarks>
        public static Bitmap Radio48x48
        {
            get { return _Radio48x48 ?? InternalResources.Radio48x48; }
            set { _Radio48x48 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Radio48x48"/> image has been customised or not.
        /// </summary>
        public static bool Radio48x48_IsCustom
        {
            get { return _Radio48x48 != null; }
        }

        private static object _Radio48x48_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Radio48x48"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Radio48x48_SyncLock
        {
            get { return _Radio48x48_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Radio48x48"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Radio48x48()
        {
            lock(Radio48x48_SyncLock) {
                return new Bitmap(Radio48x48);
            }
        }

        private static Bitmap _Rebroadcast16x16;
        /// <summary>
        /// Gets or sets the Rebroadcast16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Rebroadcast16x16.png" alt="" title="Rebroadcast16x16" />
        /// </remarks>
        public static Bitmap Rebroadcast16x16
        {
            get { return _Rebroadcast16x16 ?? InternalResources.Rebroadcast16x16; }
            set { _Rebroadcast16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Rebroadcast16x16"/> image has been customised or not.
        /// </summary>
        public static bool Rebroadcast16x16_IsCustom
        {
            get { return _Rebroadcast16x16 != null; }
        }

        private static object _Rebroadcast16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Rebroadcast16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Rebroadcast16x16_SyncLock
        {
            get { return _Rebroadcast16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Rebroadcast16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Rebroadcast16x16()
        {
            lock(Rebroadcast16x16_SyncLock) {
                return new Bitmap(Rebroadcast16x16);
            }
        }

        private static Bitmap _RowHeader;
        /// <summary>
        /// Gets or sets the RowHeader image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/RowHeader.png" alt="" title="RowHeader" />
        /// </remarks>
        public static Bitmap RowHeader
        {
            get { return _RowHeader ?? InternalResources.RowHeader; }
            set { _RowHeader = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="RowHeader"/> image has been customised or not.
        /// </summary>
        public static bool RowHeader_IsCustom
        {
            get { return _RowHeader != null; }
        }

        private static object _RowHeader_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="RowHeader"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object RowHeader_SyncLock
        {
            get { return _RowHeader_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="RowHeader"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_RowHeader()
        {
            lock(RowHeader_SyncLock) {
                return new Bitmap(RowHeader);
            }
        }

        private static Bitmap _RowHeaderSelected;
        /// <summary>
        /// Gets or sets the RowHeaderSelected image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/RowHeaderSelected.png" alt="" title="RowHeaderSelected" />
        /// </remarks>
        public static Bitmap RowHeaderSelected
        {
            get { return _RowHeaderSelected ?? InternalResources.RowHeaderSelected; }
            set { _RowHeaderSelected = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="RowHeaderSelected"/> image has been customised or not.
        /// </summary>
        public static bool RowHeaderSelected_IsCustom
        {
            get { return _RowHeaderSelected != null; }
        }

        private static object _RowHeaderSelected_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="RowHeaderSelected"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object RowHeaderSelected_SyncLock
        {
            get { return _RowHeaderSelected_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="RowHeaderSelected"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_RowHeaderSelected()
        {
            lock(RowHeaderSelected_SyncLock) {
                return new Bitmap(RowHeaderSelected);
            }
        }

        private static Bitmap _Server16x16;
        /// <summary>
        /// Gets or sets the Server16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Server16x16.png" alt="" title="Server16x16" />
        /// </remarks>
        public static Bitmap Server16x16
        {
            get { return _Server16x16 ?? InternalResources.Server16x16; }
            set { _Server16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Server16x16"/> image has been customised or not.
        /// </summary>
        public static bool Server16x16_IsCustom
        {
            get { return _Server16x16 != null; }
        }

        private static object _Server16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Server16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Server16x16_SyncLock
        {
            get { return _Server16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Server16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Server16x16()
        {
            lock(Server16x16_SyncLock) {
                return new Bitmap(Server16x16);
            }
        }

        private static Bitmap _ShowList;
        /// <summary>
        /// Gets or sets the ShowList image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/ShowList.png" alt="" title="ShowList" />
        /// </remarks>
        public static Bitmap ShowList
        {
            get { return _ShowList ?? InternalResources.ShowList; }
            set { _ShowList = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="ShowList"/> image has been customised or not.
        /// </summary>
        public static bool ShowList_IsCustom
        {
            get { return _ShowList != null; }
        }

        private static object _ShowList_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="ShowList"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object ShowList_SyncLock
        {
            get { return _ShowList_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="ShowList"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_ShowList()
        {
            lock(ShowList_SyncLock) {
                return new Bitmap(ShowList);
            }
        }

        private static Bitmap _Site16x16;
        /// <summary>
        /// Gets or sets the Site16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Site16x16.png" alt="" title="Site16x16" />
        /// </remarks>
        public static Bitmap Site16x16
        {
            get { return _Site16x16 ?? InternalResources.Site16x16; }
            set { _Site16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Site16x16"/> image has been customised or not.
        /// </summary>
        public static bool Site16x16_IsCustom
        {
            get { return _Site16x16 != null; }
        }

        private static object _Site16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Site16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Site16x16_SyncLock
        {
            get { return _Site16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Site16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Site16x16()
        {
            lock(Site16x16_SyncLock) {
                return new Bitmap(Site16x16);
            }
        }

        private static Bitmap _SmallPlaneNorth;
        /// <summary>
        /// Gets or sets the SmallPlaneNorth image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/SmallPlaneNorth.png" alt="" title="SmallPlaneNorth" />
        /// </remarks>
        public static Bitmap SmallPlaneNorth
        {
            get { return _SmallPlaneNorth ?? InternalResources.SmallPlaneNorth; }
            set { _SmallPlaneNorth = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="SmallPlaneNorth"/> image has been customised or not.
        /// </summary>
        public static bool SmallPlaneNorth_IsCustom
        {
            get { return _SmallPlaneNorth != null; }
        }

        private static object _SmallPlaneNorth_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="SmallPlaneNorth"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object SmallPlaneNorth_SyncLock
        {
            get { return _SmallPlaneNorth_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="SmallPlaneNorth"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_SmallPlaneNorth()
        {
            lock(SmallPlaneNorth_SyncLock) {
                return new Bitmap(SmallPlaneNorth);
            }
        }

        private static Bitmap _Test16x16;
        /// <summary>
        /// Gets or sets the Test16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Test16x16.png" alt="" title="Test16x16" />
        /// </remarks>
        public static Bitmap Test16x16
        {
            get { return _Test16x16 ?? InternalResources.Test16x16; }
            set { _Test16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Test16x16"/> image has been customised or not.
        /// </summary>
        public static bool Test16x16_IsCustom
        {
            get { return _Test16x16 != null; }
        }

        private static object _Test16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Test16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Test16x16_SyncLock
        {
            get { return _Test16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Test16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Test16x16()
        {
            lock(Test16x16_SyncLock) {
                return new Bitmap(Test16x16);
            }
        }

        private static Bitmap _TestSquare;
        /// <summary>
        /// Gets or sets the TestSquare image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/TestSquare.png" alt="" title="TestSquare" />
        /// </remarks>
        public static Bitmap TestSquare
        {
            get { return _TestSquare ?? InternalResources.TestSquare; }
            set { _TestSquare = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="TestSquare"/> image has been customised or not.
        /// </summary>
        public static bool TestSquare_IsCustom
        {
            get { return _TestSquare != null; }
        }

        private static object _TestSquare_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="TestSquare"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object TestSquare_SyncLock
        {
            get { return _TestSquare_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="TestSquare"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_TestSquare()
        {
            lock(TestSquare_SyncLock) {
                return new Bitmap(TestSquare);
            }
        }

        private static Bitmap _Tower;
        /// <summary>
        /// Gets or sets the Tower image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Tower.png" alt="" title="Tower" />
        /// </remarks>
        public static Bitmap Tower
        {
            get { return _Tower ?? InternalResources.Tower; }
            set { _Tower = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Tower"/> image has been customised or not.
        /// </summary>
        public static bool Tower_IsCustom
        {
            get { return _Tower != null; }
        }

        private static object _Tower_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Tower"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Tower_SyncLock
        {
            get { return _Tower_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Tower"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Tower()
        {
            lock(Tower_SyncLock) {
                return new Bitmap(Tower);
            }
        }

        private static Bitmap _Transparent_25;
        /// <summary>
        /// Gets or sets the Transparent_25 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Transparent-25.png" alt="" title="Transparent_25" />
        /// </remarks>
        public static Bitmap Transparent_25
        {
            get { return _Transparent_25 ?? InternalResources.Transparent_25; }
            set { _Transparent_25 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Transparent_25"/> image has been customised or not.
        /// </summary>
        public static bool Transparent_25_IsCustom
        {
            get { return _Transparent_25 != null; }
        }

        private static object _Transparent_25_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Transparent_25"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Transparent_25_SyncLock
        {
            get { return _Transparent_25_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Transparent_25"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Transparent_25()
        {
            lock(Transparent_25_SyncLock) {
                return new Bitmap(Transparent_25);
            }
        }

        private static Bitmap _Transparent_50;
        /// <summary>
        /// Gets or sets the Transparent_50 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Transparent-50.png" alt="" title="Transparent_50" />
        /// </remarks>
        public static Bitmap Transparent_50
        {
            get { return _Transparent_50 ?? InternalResources.Transparent_50; }
            set { _Transparent_50 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Transparent_50"/> image has been customised or not.
        /// </summary>
        public static bool Transparent_50_IsCustom
        {
            get { return _Transparent_50 != null; }
        }

        private static object _Transparent_50_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Transparent_50"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Transparent_50_SyncLock
        {
            get { return _Transparent_50_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Transparent_50"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Transparent_50()
        {
            lock(Transparent_50_SyncLock) {
                return new Bitmap(Transparent_50);
            }
        }

        private static Bitmap _Transparent_16x16;
        /// <summary>
        /// Gets or sets the Transparent_16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Transparent_16x16.png" alt="" title="Transparent_16x16" />
        /// </remarks>
        public static Bitmap Transparent_16x16
        {
            get { return _Transparent_16x16 ?? InternalResources.Transparent_16x16; }
            set { _Transparent_16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Transparent_16x16"/> image has been customised or not.
        /// </summary>
        public static bool Transparent_16x16_IsCustom
        {
            get { return _Transparent_16x16 != null; }
        }

        private static object _Transparent_16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Transparent_16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Transparent_16x16_SyncLock
        {
            get { return _Transparent_16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Transparent_16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Transparent_16x16()
        {
            lock(Transparent_16x16_SyncLock) {
                return new Bitmap(Transparent_16x16);
            }
        }

        private static Bitmap _User16x16;
        /// <summary>
        /// Gets or sets the User16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/User16x16.png" alt="" title="User16x16" />
        /// </remarks>
        public static Bitmap User16x16
        {
            get { return _User16x16 ?? InternalResources.User16x16; }
            set { _User16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="User16x16"/> image has been customised or not.
        /// </summary>
        public static bool User16x16_IsCustom
        {
            get { return _User16x16 != null; }
        }

        private static object _User16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="User16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object User16x16_SyncLock
        {
            get { return _User16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="User16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_User16x16()
        {
            lock(User16x16_SyncLock) {
                return new Bitmap(User16x16);
            }
        }

        private static Bitmap _Volume0;
        /// <summary>
        /// Gets or sets the Volume0 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Volume0.png" alt="" title="Volume0" />
        /// </remarks>
        public static Bitmap Volume0
        {
            get { return _Volume0 ?? InternalResources.Volume0; }
            set { _Volume0 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Volume0"/> image has been customised or not.
        /// </summary>
        public static bool Volume0_IsCustom
        {
            get { return _Volume0 != null; }
        }

        private static object _Volume0_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Volume0"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Volume0_SyncLock
        {
            get { return _Volume0_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Volume0"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Volume0()
        {
            lock(Volume0_SyncLock) {
                return new Bitmap(Volume0);
            }
        }

        private static Bitmap _Volume100;
        /// <summary>
        /// Gets or sets the Volume100 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Volume100.png" alt="" title="Volume100" />
        /// </remarks>
        public static Bitmap Volume100
        {
            get { return _Volume100 ?? InternalResources.Volume100; }
            set { _Volume100 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Volume100"/> image has been customised or not.
        /// </summary>
        public static bool Volume100_IsCustom
        {
            get { return _Volume100 != null; }
        }

        private static object _Volume100_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Volume100"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Volume100_SyncLock
        {
            get { return _Volume100_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Volume100"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Volume100()
        {
            lock(Volume100_SyncLock) {
                return new Bitmap(Volume100);
            }
        }

        private static Bitmap _Volume25;
        /// <summary>
        /// Gets or sets the Volume25 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Volume25.png" alt="" title="Volume25" />
        /// </remarks>
        public static Bitmap Volume25
        {
            get { return _Volume25 ?? InternalResources.Volume25; }
            set { _Volume25 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Volume25"/> image has been customised or not.
        /// </summary>
        public static bool Volume25_IsCustom
        {
            get { return _Volume25 != null; }
        }

        private static object _Volume25_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Volume25"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Volume25_SyncLock
        {
            get { return _Volume25_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Volume25"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Volume25()
        {
            lock(Volume25_SyncLock) {
                return new Bitmap(Volume25);
            }
        }

        private static Bitmap _Volume50;
        /// <summary>
        /// Gets or sets the Volume50 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Volume50.png" alt="" title="Volume50" />
        /// </remarks>
        public static Bitmap Volume50
        {
            get { return _Volume50 ?? InternalResources.Volume50; }
            set { _Volume50 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Volume50"/> image has been customised or not.
        /// </summary>
        public static bool Volume50_IsCustom
        {
            get { return _Volume50 != null; }
        }

        private static object _Volume50_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Volume50"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Volume50_SyncLock
        {
            get { return _Volume50_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Volume50"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Volume50()
        {
            lock(Volume50_SyncLock) {
                return new Bitmap(Volume50);
            }
        }

        private static Bitmap _Volume75;
        /// <summary>
        /// Gets or sets the Volume75 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Volume75.png" alt="" title="Volume75" />
        /// </remarks>
        public static Bitmap Volume75
        {
            get { return _Volume75 ?? InternalResources.Volume75; }
            set { _Volume75 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Volume75"/> image has been customised or not.
        /// </summary>
        public static bool Volume75_IsCustom
        {
            get { return _Volume75 != null; }
        }

        private static object _Volume75_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Volume75"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Volume75_SyncLock
        {
            get { return _Volume75_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Volume75"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Volume75()
        {
            lock(Volume75_SyncLock) {
                return new Bitmap(Volume75);
            }
        }

        private static Bitmap _VolumeDown;
        /// <summary>
        /// Gets or sets the VolumeDown image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/VolumeDown.png" alt="" title="VolumeDown" />
        /// </remarks>
        public static Bitmap VolumeDown
        {
            get { return _VolumeDown ?? InternalResources.VolumeDown; }
            set { _VolumeDown = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="VolumeDown"/> image has been customised or not.
        /// </summary>
        public static bool VolumeDown_IsCustom
        {
            get { return _VolumeDown != null; }
        }

        private static object _VolumeDown_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="VolumeDown"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object VolumeDown_SyncLock
        {
            get { return _VolumeDown_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="VolumeDown"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_VolumeDown()
        {
            lock(VolumeDown_SyncLock) {
                return new Bitmap(VolumeDown);
            }
        }

        private static Bitmap _VolumeMute;
        /// <summary>
        /// Gets or sets the VolumeMute image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/VolumeMute.png" alt="" title="VolumeMute" />
        /// </remarks>
        public static Bitmap VolumeMute
        {
            get { return _VolumeMute ?? InternalResources.VolumeMute; }
            set { _VolumeMute = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="VolumeMute"/> image has been customised or not.
        /// </summary>
        public static bool VolumeMute_IsCustom
        {
            get { return _VolumeMute != null; }
        }

        private static object _VolumeMute_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="VolumeMute"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object VolumeMute_SyncLock
        {
            get { return _VolumeMute_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="VolumeMute"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_VolumeMute()
        {
            lock(VolumeMute_SyncLock) {
                return new Bitmap(VolumeMute);
            }
        }

        private static Bitmap _VolumeUp;
        /// <summary>
        /// Gets or sets the VolumeUp image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/VolumeUp.png" alt="" title="VolumeUp" />
        /// </remarks>
        public static Bitmap VolumeUp
        {
            get { return _VolumeUp ?? InternalResources.VolumeUp; }
            set { _VolumeUp = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="VolumeUp"/> image has been customised or not.
        /// </summary>
        public static bool VolumeUp_IsCustom
        {
            get { return _VolumeUp != null; }
        }

        private static object _VolumeUp_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="VolumeUp"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object VolumeUp_SyncLock
        {
            get { return _VolumeUp_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="VolumeUp"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_VolumeUp()
        {
            lock(VolumeUp_SyncLock) {
                return new Bitmap(VolumeUp);
            }
        }

        private static Bitmap _WarningBitmap;
        /// <summary>
        /// Gets or sets the WarningBitmap image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/WarningBitmap.png" alt="" title="WarningBitmap" />
        /// </remarks>
        public static Bitmap WarningBitmap
        {
            get { return _WarningBitmap ?? InternalResources.WarningBitmap; }
            set { _WarningBitmap = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="WarningBitmap"/> image has been customised or not.
        /// </summary>
        public static bool WarningBitmap_IsCustom
        {
            get { return _WarningBitmap != null; }
        }

        private static object _WarningBitmap_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="WarningBitmap"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object WarningBitmap_SyncLock
        {
            get { return _WarningBitmap_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="WarningBitmap"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_WarningBitmap()
        {
            lock(WarningBitmap_SyncLock) {
                return new Bitmap(WarningBitmap);
            }
        }

        private static Icon _WarningIcon;
        /// <summary>
        /// Gets or sets the WarningIcon image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/WarningIcon.ico" alt="" title="WarningIcon" />
        /// </remarks>
        public static Icon WarningIcon
        {
            get { return _WarningIcon ?? InternalResources.WarningIcon; }
            set { _WarningIcon = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="WarningIcon"/> image has been customised or not.
        /// </summary>
        public static bool WarningIcon_IsCustom
        {
            get { return _WarningIcon != null; }
        }

        private static object _WarningIcon_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="WarningIcon"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object WarningIcon_SyncLock
        {
            get { return _WarningIcon_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="WarningIcon"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Icon Clone_WarningIcon()
        {
            lock(WarningIcon_SyncLock) {
                return Icon.FromHandle(WarningIcon.Handle);
            }
        }

        private static Bitmap _Wizard16x16;
        /// <summary>
        /// Gets or sets the Wizard16x16 image.
        /// </summary>
        /// <remarks>
        /// <img src="../Images/Wizard16x16.png" alt="" title="Wizard16x16" />
        /// </remarks>
        public static Bitmap Wizard16x16
        {
            get { return _Wizard16x16 ?? InternalResources.Wizard16x16; }
            set { _Wizard16x16 = value; }
        }

        /// <summary>
        /// Gets a value indicating whether the <see cref="Wizard16x16"/> image has been customised or not.
        /// </summary>
        public static bool Wizard16x16_IsCustom
        {
            get { return _Wizard16x16 != null; }
        }

        private static object _Wizard16x16_SyncLock = new Object();
        /// <summary>
        /// Gets an object that can be used in a lock() statement on the image to force single-thread access to it while
        /// performing some operation on it.
        /// </summary>
        /// <remarks>
        /// This is a recipe for deadlocking, be careful when using this lock that you do not call anything that
        /// will acquire another lock elsewhere. If in doubt then call <see cref="Wizard16x16"/> to make a thread-clone of the
        /// image and use that in your image manipulations.
        /// </remarks>
        public static object Wizard16x16_SyncLock
        {
            get { return _Wizard16x16_SyncLock; }
        }

        /// <summary>
        /// Creates a copy of <see cref="Wizard16x16"/>. Despite the name this does not use Clone, it creates
        /// a fresh copy.
        /// </summary>
        public static Bitmap Clone_Wizard16x16()
        {
            lock(Wizard16x16_SyncLock) {
                return new Bitmap(Wizard16x16);
            }
        }
    }
}
